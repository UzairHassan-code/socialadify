# D:\socialadify\backend\app\api\captions\router.py
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from fastapi.concurrency import run_in_threadpool
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated, List, Optional
import os
import shutil
from pathlib import Path
import logging

# Gradio Client
from gradio_client import Client as GradioClient, handle_file as gradio_handle_file

# Gemini AI
import google.generativeai as genai

from app.schemas.user import UserInDB
from app.core.security import get_current_active_user
from app.db.session import get_database
from .schemas import CaptionPreferences, GeneratedCaptionResponse, ErrorResponse

router = APIRouter()
logger = logging.getLogger(__name__)

# --- Configuration ---
# For Gradio (BLIP Image Description)
HF_SPACE_ID = os.getenv("HF_SPACE_ID", "uzair-hassan003/SocialAdify") # Default if not in .env
TEMP_IMAGE_DIR = Path("./temp_images")
TEMP_IMAGE_DIR.mkdir(parents=True, exist_ok=True) # Ensure temp directory exists

# For Gemini
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# --- Dependencies ---
DbDependency = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
CurrentUserDependency = Annotated[UserInDB, Depends(get_current_active_user)]


# --- Helper Functions ---

def get_blip_image_description(image_path: Path) -> Optional[str]:
    """
    Connects to Hugging Face Space using Gradio client to get image description.
    This function contains a blocking I/O call and should be run in a threadpool.
    """
    logger.info(f"Connecting to Hugging Face Space: {HF_SPACE_ID} for image description of {image_path}.")
    try:
        # Ensure the image path is a string for gradio_handle_file
        image_file_path_str = str(image_path.resolve())
        
        client = GradioClient(HF_SPACE_ID)
        logger.info(f"Sending image '{image_file_path_str}' to HF Space API (endpoint: /predict)...")
        
        # This is a synchronous (blocking) call
        blip_description_result = client.predict(
            image=gradio_handle_file(image_file_path_str),
            api_name="/predict"
        )
        
        if isinstance(blip_description_result, str):
            description = blip_description_result.strip()
            if description:
                logger.info(f"BLIP Image Description received: \"{description}\"")
                return description
            else:
                logger.warning("BLIP description received is empty.")
                return None
        else:
            logger.warning(f"Received unexpected result type from BLIP: {type(blip_description_result)}")
            logger.warning(f"Full result from BLIP: {blip_description_result}")
            return None
    except Exception as e:
        logger.error(f"An error occurred while getting BLIP description for {image_path}: {e}", exc_info=True)
        return None

def construct_gemini_prompt_internal(image_desc: Optional[str], prefs: CaptionPreferences) -> str:
    """Constructs a detailed prompt for the Gemini API to generate a single caption."""
    prompt = "You are an expert social media caption writer.\n"
    # MODIFIED: Ask for a single caption
    prompt += "Your task is to generate an engaging and creative caption for a social media post based on the following information:\n\n"

    if image_desc:
        prompt += f"1.  **Image Description (generated by an AI model):**\n    \"{image_desc}\"\n\n"
    else:
        prompt += "1.  **Image:** No image was provided or its description could not be obtained. Focus on the category and tone.\n\n"

    prompt += f"2.  **Post Category:**\n    \"{prefs.category}\"\n\n"
    prompt += f"3.  **Desired Tone/Style:**\n    \"{prefs.tone}\"\n\n"

    if prefs.include_hashtags:
        # MODIFIED: Instruction for a single caption
        prompt += "4. **Hashtags:** Please include 3-5 relevant and effective hashtags at the end of the caption.\n\n"
    else:
        prompt += "4. **Hashtags:** Do not include any hashtags.\n\n"

    if prefs.include_emojis:
        # MODIFIED: Instruction for a single caption
        prompt += "5. **Emojis:** Please integrate relevant emojis naturally within the caption to enhance its appeal.\n\n"
    else:
        prompt += "5. **Emojis:** Do not include any emojis.\n\n"

    # MODIFIED: Instructions for a single caption output
    prompt += """
Based on all the above, please write one compelling social media caption.
The caption should be concise (around 1-3 sentences, unless the tone implies otherwise), engaging, and suitable for platforms like Instagram, Facebook, or X (Twitter).
Focus on creativity and making the caption interesting for the target audience of the specified category and tone.
Only output the final caption text. Do not include any preamble like "Here's a caption:" or numbering.
"""
    return prompt

async def generate_captions_with_gemini_async(prompt_text: str) -> List[str]:
    """Sends the prompt to the Gemini API asynchronously and returns a list containing a single generated caption."""
    if not GEMINI_API_KEY:
        logger.error("GEMINI_API_KEY environment variable not set.")
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Caption generation service is not configured (API Key missing).")

    try:
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-1.5-flash-latest')
        generation_config = genai.types.GenerationConfig(
            temperature=0.75,
            max_output_tokens=250 # Adjusted for a single, potentially rich caption
        )
        
        logger.info("Sending prompt to Gemini for single caption generation...")
        response = await model.generate_content_async(
            prompt_text,
            generation_config=generation_config
        )
        
        generated_text = ""
        if response.parts:
            generated_text = response.parts[0].text.strip()
        elif hasattr(response, 'text'): 
            generated_text = response.text.strip()
        
        if not generated_text and response.prompt_feedback and response.prompt_feedback.block_reason:
            block_message = f"Caption generation blocked. Reason: {response.prompt_feedback.block_reason_message or response.prompt_feedback.block_reason}"
            logger.warning(block_message)
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=block_message)
        
        if not generated_text:
            logger.warning("Gemini returned empty text for the caption.")
            return ["Could not generate a caption at this time. Please try again."]

        # Return the single caption as a list with one element
        logger.info(f"Gemini generated single caption: \"{generated_text[:100]}...\"")
        return [generated_text]

    except Exception as e:
        logger.error(f"An error occurred while communicating with Gemini API: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=f"Error generating caption via Gemini: {str(e)}")


@router.post(
    "/generate",
    response_model=GeneratedCaptionResponse,
    responses={
        status.HTTP_500_INTERNAL_SERVER_ERROR: {"model": ErrorResponse},
        status.HTTP_503_SERVICE_UNAVAILABLE: {"model": ErrorResponse},
        status.HTTP_400_BAD_REQUEST: {"model": ErrorResponse},
    }
)
async def generate_captions_endpoint(
    current_user: CurrentUserDependency, 
    db: DbDependency, 
    category: str = Form(...),
    tone: str = Form(...),
    include_hashtags: bool = Form(...),
    include_emojis: bool = Form(...),
    image_file: Optional[UploadFile] = File(None) 
):
    logger.info(f"Single caption generation request for user: {current_user.email}")
    logger.info(f"Preferences: Category='{category}', Tone='{tone}', Hashtags={include_hashtags}, Emojis={include_emojis}, Image provided: {image_file is not None}")

    caption_prefs = CaptionPreferences(
        category=category,
        tone=tone,
        include_hashtags=include_hashtags,
        include_emojis=include_emojis
    )

    blip_description: Optional[str] = None
    temp_image_path: Optional[Path] = None

    if image_file:
        if not image_file.content_type or not image_file.content_type.startswith("image/"):
            logger.warning(f"Invalid image file type: {image_file.content_type}")
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file type. Please upload an image.")
        
        try:
            temp_image_path = TEMP_IMAGE_DIR / f"{current_user.id}_{image_file.filename}" 
            with open(temp_image_path, "wb") as buffer:
                shutil.copyfileobj(image_file.file, buffer)
            logger.info(f"Temporary image saved to: {temp_image_path}")

            blip_description = await run_in_threadpool(get_blip_image_description, temp_image_path)
            
            if not blip_description:
                logger.warning("Failed to get image description from BLIP service, proceeding without it.")
        
        except Exception as e:
            logger.error(f"Error processing image file or getting BLIP description: {e}", exc_info=True)
            blip_description = None 
        finally:
            if temp_image_path and temp_image_path.exists():
                try:
                    os.remove(temp_image_path)
                    logger.info(f"Temporary image deleted: {temp_image_path}")
                except Exception as e_del:
                    logger.error(f"Error deleting temporary image {temp_image_path}: {e_del}", exc_info=True)
    
    gemini_prompt = construct_gemini_prompt_internal(blip_description, caption_prefs)
    logger.debug(f"Constructed Gemini Prompt (first 100 chars for single caption):\n{gemini_prompt[:100]}...")

    try:
        generated_captions_list = await generate_captions_with_gemini_async(gemini_prompt)
    except HTTPException as e: 
        logger.error(f"HTTPException from Gemini generation: {e.detail}")
        raise e
    except Exception as e: 
        logger.error(f"Unexpected error during Gemini caption generation: {e}", exc_info=True)
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to generate captions due to an internal error.")

    if not generated_captions_list or not generated_captions_list[0]: # Check if the list is empty or first item is empty
        logger.warning("Gemini returned no valid caption.")
        generated_captions_list = ["Failed to generate a caption. Please try again or adjust preferences."]

    return GeneratedCaptionResponse(
        captions=generated_captions_list, # Will be a list with one caption
        image_description_used=blip_description 
    )

